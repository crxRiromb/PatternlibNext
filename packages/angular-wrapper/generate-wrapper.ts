import * as fs from "fs";
import * as path from "path";

// --- CONFIGURATION ---
const cemPath = path.resolve(
  process.cwd(),
  "../../packages/lit/custom-elements.json",
);
const componentTagName = "pl-button";
// --- END CONFIGURATION ---

function toCamelCase(str) {
  return str.replace(/-([a-z])/g, (g) => g[1].toUpperCase());
}

function toPascalCase(str) {
  const camel = toCamelCase(str);
  return camel.charAt(0).toUpperCase() + camel.slice(1);
}

function generateWrapper() {
  if (!fs.existsSync(cemPath)) {
    console.error(`❌ Error: custom-elements.json not found at ${cemPath}`);
    return;
  }

  const cem = JSON.parse(fs.readFileSync(cemPath, "utf-8"));
  const componentDef = cem.modules
    .flatMap((m) => m.declarations)
    .find((d) => d.tagName === componentTagName);

  if (!componentDef) {
    console.error(
      `❌ Error: Component definition for <${componentTagName}> not found in manifest.`,
    );
    return;
  }

  const angularComponentName = `${toPascalCase(componentTagName)}Angular`;
  const litComponentType = toPascalCase(componentTagName);

  // --- Generate Inputs ---
  const inputs = (componentDef.attributes || [])
    .map((attr) => {
      const propName = toCamelCase(attr.name || attr.fieldName);
      const type = attr.type?.text || "string";
      const isBoolean = type.toLowerCase() === "boolean";

      if (isBoolean) {
        return `
  // Maps to the '${attr.name}' attribute of the web component.
  @Input({ transform: booleanAttribute }) ${propName}: ${type} = false;`;
      }

      return `
  private _${propName}: ${type} = '';
  // Maps to the '${attr.name}' attribute of the web component.
  @Input()
  set ${propName}(value: ${type} | null | undefined) {
    this._${propName} = value ?? '';
  }
  get ${propName}(): ${type} {
    return this._${propName};
  }`;
    })
    .join("\n");

  // --- Generate Outputs ---
  const outputs = (componentDef.events || [])
    .map((event) => {
      const eventName = toCamelCase(event.name);
      return `
  // Emits when the '${event.name}' event is fired by the web component.
  @Output() ${eventName} = new EventEmitter<CustomEvent>();`;
    })
    .join("\n");

  // --- Generate Event Listeners ---
  const eventListeners = (componentDef.events || [])
    .map((event) => {
      const eventName = toCamelCase(event.name);
      return `
    nativeElement.addEventListener('${event.name}', (event: Event) => {
      this.${eventName}.emit(event as CustomEvent);
    });`;
    })
    .join("");

  // --- Generate Template Bindings ---
  const templateBindings = (componentDef.attributes || [])
    .map((attr) => {
      const propName = toCamelCase(attr.name || attr.fieldName);
      const isBoolean = (attr.type?.text || "").toLowerCase() === "boolean";
      return `[${attr.name}]="${isBoolean ? propName : `_${propName}`}"`;
    })
    .join("\n      ");

  // --- Assemble the full component file ---
  const template = `
// THIS FILE IS AUTO-GENERATED BY THE WRAPPER-GENERATOR SCRIPT. DO NOT EDIT.

import {
  Component,
  ChangeDetectionStrategy,
  Input,
  Output,
  EventEmitter,
  ElementRef,
  ViewChild,
  AfterViewInit,
  CUSTOM_ELEMENTS_SCHEMA,
  booleanAttribute,
} from "@angular/core";
import type { ${litComponentType} } from "@liebherr2/plnext";

@Component({
  selector: "${componentTagName}-angular",
  standalone: true,
  template: \`
    <${componentTagName}
      #elementRef
      ${templateBindings}
    >
      <ng-content></ng-content>
    </${componentTagName}>
  \`,
  styles: [":host { display: inline-block; }"],
  changeDetection: ChangeDetectionStrategy.OnPush,
  schemas: [CUSTOM_ELEMENTS_SCHEMA],
})
export class ${angularComponentName} implements AfterViewInit {
  @ViewChild("elementRef") elementRef!: ElementRef<${litComponentType}>;

  // --- Inputs ---
  ${inputs}

  // --- Outputs ---
  ${outputs}

  ngAfterViewInit() {
    const nativeElement = this.elementRef.nativeElement;
    ${eventListeners}
  }
}
`;

  // --- Write the file ---
  const componentSubfolder = componentTagName.replace("pl-", ""); // e.g., 'button'
  const finalOutputDir = path.resolve(
    process.cwd(),
    "./src",
    componentSubfolder,
  );
  const outputFilePath = path.join(
    finalOutputDir,
    `${componentSubfolder}.component.ts`,
  );

  fs.mkdirSync(finalOutputDir, { recursive: true });
  fs.writeFileSync(outputFilePath, template.trim());
  console.log(
    `✅ Successfully generated wrapper for <${componentTagName}> at ${outputFilePath}`,
  );
}

generateWrapper();
