import * as fs from "fs";
import * as path from "path";

const cemPath = path.resolve(
  process.cwd(),
  "../../packages/lit/custom-elements.json",
);
const outputSrcDir = path.resolve(process.cwd(), "./src");

function toCamelCase(str: string): string {
  if (!str) return "";
  return str.replace(/-([a-z])/g, (g) => g[1].toUpperCase());
}

function toPascalCase(str: string): string {
  const camel = toCamelCase(str);
  return camel.charAt(0).toUpperCase() + camel.slice(1);
}

function generateComponentWrapper(componentDef) {
  const { tagName } = componentDef;
  const angularComponentName = `${toPascalCase(tagName)}Angular`;
  const litComponentType = toPascalCase(tagName);

  // Combine 'attributes' and 'fields' to capture all public properties.
  const propMap = new Map();
  (componentDef.attributes || []).forEach((attr) =>
    propMap.set(attr.name, attr),
  );
  (componentDef.fields || []).forEach((field) => {
    if (field.privacy !== "private" && field.kind === "field") {
      propMap.set(field.name, field);
    }
  });
  const allProperties = Array.from(propMap.values());

  // --- Generate Inputs ---
  const inputs = allProperties
    .map((prop) => {
      const propName = toCamelCase(prop.name || prop.fieldName);
      const type = (prop.type?.text || "string").replace(/'/g, '"');
      const isBoolean = type.toLowerCase() === "boolean";
      const isString = type.toLowerCase() === "string";
      // A complex property is now identified as anything that isn't a string or boolean.
      const isComplexProperty = !isBoolean && !isString;

      if (isBoolean) {
        return `
  /** Maps to the "${prop.name}" attribute of the web component. */
  @Input({ transform: booleanAttribute }) ${propName}: ${type} = false;`;
      }

      // Generate a simple Input for complex properties.
      if (isComplexProperty) {
        const defaultValue = prop.defaultValue || prop.default || "undefined";
        return `
  /** Maps to the "${prop.name}" property of the web component. */
  @Input() ${propName}?: ${type} = ${defaultValue};`;
      }

      // Default handling for string-based attributes.
      const defaultValue = prop.defaultValue || prop.default;
      const cleanedDefaultValue = defaultValue
        ? defaultValue.replace(/['"]/g, "")
        : "";
      const defaultValueForCode = `"${cleanedDefaultValue}"`;

      return `
  protected _${propName}: ${type} = ${defaultValueForCode};
  /** Maps to the "${prop.name}" attribute of the web component. */
  @Input()
  set ${propName}(value: ${type} | null | undefined) {
    this._${propName} = value ?? ${cleanedDefaultValue ? `"${cleanedDefaultValue}"` : '""'};
  }
  get ${propName}(): ${type} {
    return this._${propName};
  }`;
    })
    .join("\n");

  // --- Generate Outputs ---
  const outputs = (componentDef.events || [])
    .map((event) => {
      const eventName = toCamelCase(event.name);
      return `
  /** Emits when the "${event.name}" event is fired by the web component. */
  @Output() ${eventName} = new EventEmitter<CustomEvent>();`;
    })
    .join("\n");

  // --- Generate Event Listeners ---
  const eventListeners = (componentDef.events || [])
    .map((event) => {
      const eventName = toCamelCase(event.name);
      return `
    nativeElement.addEventListener("${event.name}", (event: Event) => {
      this.${eventName}.emit(event as CustomEvent);
    });`;
    })
    .join("");

  // --- Generate Template Bindings ---
  const templateBindings = allProperties
    .map((prop) => {
      const propName = toCamelCase(prop.name || prop.fieldName);
      const type = prop.type?.text || "string";
      const isBoolean = type.toLowerCase() === "boolean";
      const isString = type.toLowerCase() === "string";
      const isComplexProperty = !isBoolean && !isString;

      const attributeName = prop.name || prop.fieldName;

      // Use property binding for complex types and booleans.
      if (isComplexProperty || isBoolean) {
        return `[${attributeName}]="${propName}"`;
      }

      // Use binding to the sanitized, private property for strings.
      return `[${attributeName}]="_${propName}"`;
    })
    .join("\n      ");

  // --- Assemble the full component file ---
  return `
// THIS FILE IS AUTO-GENERATED BY THE WRAPPER-GENERATOR SCRIPT. DO NOT EDIT.

import {
  Component,
  ChangeDetectionStrategy,
  Input,
  Output,
  EventEmitter,
  ElementRef,
  ViewChild,
  AfterViewInit,
  CUSTOM_ELEMENTS_SCHEMA,
  booleanAttribute,
} from "@angular/core";
import type { ${litComponentType} } from "@liebherr2/plnext";

@Component({
  selector: "${tagName}-angular",
  standalone: true,
  template: \`
    <${tagName}
      #elementRef
      ${templateBindings}
    >
      <ng-content></ng-content>
    </${tagName}>
  \`,
  styles: [":host { display: inline-block; }"],
  changeDetection: ChangeDetectionStrategy.OnPush,
  schemas: [CUSTOM_ELEMENTS_SCHEMA],
})
export class ${angularComponentName} implements AfterViewInit {
  @ViewChild("elementRef") elementRef!: ElementRef<${litComponentType}>;

  // --- Inputs ---
  ${inputs}

  // --- Outputs ---
  ${outputs}

  // --- Lifecycle hooks ---
  ngAfterViewInit() {
    const nativeElement = this.elementRef.nativeElement;
    ${eventListeners}
  }
}
`;
}

function main() {
  const componentsToGenerate = process.argv.slice(2);

  if (!fs.existsSync(cemPath)) {
    console.error(`❌ Error: custom-elements.json not found at ${cemPath}`);
    process.exit(1);
  }

  console.log("Reading custom-elements.json...");
  const cem = JSON.parse(fs.readFileSync(cemPath, "utf-8"));
  const allComponentDefs = cem.modules.flatMap((m: any) =>
    (m.declarations || []).filter((d: any) => d.customElement),
  );

  let targetComponentDefs = allComponentDefs;

  if (componentsToGenerate.length > 0) {
    console.log(
      `Generating wrappers for specified components: ${componentsToGenerate.join(", ")}`,
    );
    targetComponentDefs = allComponentDefs.filter((def: { tagName: string }) =>
      componentsToGenerate.includes(def.tagName),
    );
  } else {
    console.log(
      "No specific components listed, generating for all found components...",
    );
  }

  const generatedFilePaths = [];

  for (const componentDef of targetComponentDefs) {
    if (!componentDef.tagName) {
      console.warn(
        `⚠️ Skipping declaration "${componentDef.name}" because it has no tagName.`,
      );
      continue;
    }

    const componentCode = generateComponentWrapper(componentDef);
    const componentSubfolder = componentDef.tagName.replace("pl-", "");
    const finalOutputDir = path.join(outputSrcDir, componentSubfolder);
    const outputFilePath = path.join(
      finalOutputDir,
      `${componentSubfolder}.component.ts`,
    );

    fs.mkdirSync(finalOutputDir, { recursive: true });
    fs.writeFileSync(outputFilePath, componentCode.trim());
    console.log(
      `✅ Successfully generated wrapper for <${componentDef.tagName}> at ${outputFilePath}`,
    );
    generatedFilePaths.push(
      `./${componentSubfolder}/${componentSubfolder}.component.ts`,
    );
  }

  // --- Generate public-api.ts ---
  console.log("Generating public-api.ts...");
  const publicApiContent = generatedFilePaths
    .map((p) => `export * from '${p.replace(".ts", "")}';`)
    .join("\n");
  fs.writeFileSync(path.join(outputSrcDir, "public-api.ts"), publicApiContent);
  console.log("✅ Successfully generated public-api.ts");

  console.log("\n✨ Wrapper generation complete!");
}

main();
